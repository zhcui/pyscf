

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.7. df — Density fitting &mdash; PySCF 1.7.5 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10.8. dft — Density functional theory" href="dft.html" />
    <link rel="prev" title="10.6. data — Data for constants" href="data.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">2. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-rule.html">4. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">5. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">6. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">7. Theoretical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">8. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interface.html">9. Interfaces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../modules.html">10. Main modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="adc.html">10.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">adc</span></code> — Algebraic diagrammatic construction (ADC) scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="ao2mo.html">10.2. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ao2mo</span></code> — Integral transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="cc.html">10.3. <code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code> — Coupled cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="ccn.html">10.4. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ccn</span></code> — Auto-generated coupled cluster of arbitrary order</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">10.5. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ci</span></code> — Configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">10.6. <code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code> — Data for constants</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.7. <code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code> — Density fitting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">10.7.1. Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#df-auxiliary-basis">10.7.1.1. DF auxiliary basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#saving-loading-df-integral-tensor">10.7.1.2. Saving/Loading DF integral tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#approximating-orbital-hessian-in-scf-and-mcscf">10.7.1.3. Approximating orbital hessian in SCF and MCSCF</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#examples">10.7.2. Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#program-reference">10.7.3. Program reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#df-class">10.7.3.1. DF class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.df.incore">10.7.3.2. df.incore</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.df.outcore">10.7.3.3. df.outcore</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.df.addons">10.7.3.4. df.addons</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.df.df">10.7.3.5. df.df</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.df.df_jk">10.7.3.6. df.df_jk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-r-incore">10.7.3.7. df.r_incore</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-grad-rhf">10.7.3.8. df.grad.rhf</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-grad-uhf">10.7.3.9. df.grad.uhf</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-grad-rks">10.7.3.10. df.grad.rks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-grad-uks">10.7.3.11. df.grad.uks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-hessian-rhf">10.7.3.12. df.hessian.rhf</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-hessian-uhf">10.7.3.13. df.hessian.uhf</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-hessian-rks">10.7.3.14. df.hessian.rks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#df-hessian-uks">10.7.3.15. df.hessian.uks</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">10.8. <code class="xref py py-mod docutils literal notranslate"><span class="pre">dft</span></code> — Density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="doci.html">10.9. <code class="xref py py-mod docutils literal notranslate"><span class="pre">doci</span></code> — Doubly occupied configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="fci.html">10.10. <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> — Full configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="grad.html">10.11. <code class="xref py py-mod docutils literal notranslate"><span class="pre">grad</span></code> — Analytical nuclear gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="gto.html">10.12. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gto</span></code> — Molecular structure and GTO basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">10.13. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gw</span></code> — Molecular G0W0</a></li>
<li class="toctree-l2"><a class="reference internal" href="hci.html">10.14. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hci</span></code> — Heat-bath selected CI</a></li>
<li class="toctree-l2"><a class="reference internal" href="hessian.html">10.15. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hessian</span></code> — Analytical nuclear Hessian</a></li>
<li class="toctree-l2"><a class="reference internal" href="lib.html">10.16. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lib</span></code> — Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="lo.html">10.17. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lo</span></code> — Orbital localization and analysis tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="mcscf.html">10.18. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> — Multi-configurational self-consistent field</a></li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">10.19. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mp</span></code> — MP2</a></li>
<li class="toctree-l2"><a class="reference internal" href="mrpt.html">10.20. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mrpt</span></code> — Multi-reference perturbation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="pbc.html">10.21. <code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc</span></code> — Periodic boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="prop.html">10.22. <code class="xref py py-mod docutils literal notranslate"><span class="pre">prop</span></code> — Molecular properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmmm.html">10.23. <code class="xref py py-mod docutils literal notranslate"><span class="pre">qmmm</span></code> — QM/MM interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rt.html">10.24. <code class="xref py py-mod docutils literal notranslate"><span class="pre">rt</span></code> — Real-time time-dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="scf.html">10.25. <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code> — Self-consistent field methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="semiempirical.html">10.26. <code class="xref py py-mod docutils literal notranslate"><span class="pre">semiempirical</span></code> — Semiempirical methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="sgx.html">10.27. <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgx</span></code> — Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvent.html">10.28. <code class="xref py py-mod docutils literal notranslate"><span class="pre">solvent</span></code> — Solvent methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="soscf.html">10.29. <code class="xref py py-mod docutils literal notranslate"><span class="pre">soscf</span></code> — Second order SCF solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="symm.html">10.30. <code class="xref py py-mod docutils literal notranslate"><span class="pre">symm</span></code> – Point group symmetry and spin symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="tdscf.html">10.31. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tdscf</span></code> — TDHF and TDDFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">10.32. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tools</span></code> — Useful tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="x2c.html">10.33. <code class="xref py py-mod docutils literal notranslate"><span class="pre">x2c</span></code> — exact-two-component approach</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../modules.html">10. Main modules</a> &raquo;</li>
        
      <li>10.7. <code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code> — Density fitting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/df.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-df">
<span id="df-density-fitting"></span><span id="mol-df"></span><h1>10.7. <a class="reference internal" href="#module-df" title="df: Density fitting and RI approximation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code></a> — Density fitting<a class="headerlink" href="#module-df" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>10.7.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-df" title="df: Density fitting and RI approximation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code></a> module provides the fundamental functions to handle the 3-index
tensors required by the density fitting (DF) method or the resolution of
identity (RI) approximation.  Specifically, it includes the functions to compute
the 3-center 2-electron AO integrals, the DF/RI 3-index tensor in the form of
Cholesky decomposed integral tensor (<span class="math notranslate nohighlight">\((ij|kl)=V_{ij,x}V_{kl,x}\)</span>),
the AO to MO integral transformation of the 3-index tensor, as well as the
functions to generate the density fitting basis.</p>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">density_fit()</span></code> method can utilize the DF method at SCF and MCSCF
level:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Once the DF method is enabled at the SCF level, all the post-SCF methods will
automatically enable the DF method, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span><span class="p">,</span> <span class="n">tddft</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">td</span> <span class="o">=</span> <span class="n">tddft</span><span class="o">.</span><span class="n">TDA</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">td</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>In PySCF, DF is implemented at different level of implementations for different
methods.  They are summarized in the following table</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Methods</p></td>
<td><p>Fake-ERI</p></td>
<td><p>Native DF</p></td>
<td><p>Properties with DF</p></td>
</tr>
<tr class="row-even"><td><p>HF/DFT</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Generlized HF/DFT</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Relativistic HF</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>TDDFT</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>RCCSD</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>UCCSD</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>RCCSD(T)</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>EOM-CCSD</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>RMP2</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>UMP2</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>PBC HF/DFT</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>PBC TDDFT</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>PBC Gamma-point CCSD</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>PBC k-points CCSD</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Fake-ERI means to mimic the 4-center 2-electron repulsion integrals (ERI) by
precontracting the DF 3-index tensor.
This is the simplest way to enable DF integrals, although the fake-ERI mechanism
may require huge amount of memory also may be slow in performance.  It provides
the most convenient way to embed the DF integrals in the existing code, thus it
is supported by almost every method in PySCF.  It is particularly important in
the periodic code.  Using the fake-ERIs allows us to call all quantum chemistry
methods developed at molecular level in the <span class="math notranslate nohighlight">\(\Gamma\)</span>-point calculations
without modifying any existing molecular code.  See also the <a class="reference internal" href="pbc/df.html#pbc-df"><span class="std std-ref">pbc.df — PBC denisty fitting</span></a>
module.</p>
<p>Some methods have native DF implementation.  This means the performance of the
DF technique has been considered in the code.  In these methods, DF
approximation generally runs faster than the regular scheme without integral
approximation and also consumes less memory or disk space.</p>
<p>When density fitting is enabled in a method, a <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> object will be
generated and attached to the method object.  <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> is the object to
hold all DF relevant quantiles, such as the DF basis, the file to save the
3-index tensor, the amount of memory to use etc.  You can modify the attributes
of <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> to get more control over the DF methods.  In the SCF and
MCSCF methods, setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code> will switch off the DF
approximation.  In the periodic code, all two-electron integrals are evaluated
by DF approximations.  There are four different types of DF schemes
(<code class="xref py py-class docutils literal notranslate"><span class="pre">FFTDF</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AFTDF</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">GDF</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MDF</span></code> see <a class="reference internal" href="pbc/df.html#pbc-df"><span class="std std-ref">pbc.df — PBC denisty fitting</span></a>),
available in the periodic code.  By assigning different DF object to
<code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code>, different DF schemes can be applied in the PBC calculations.</p>
<div class="section" id="df-auxiliary-basis">
<span id="df-auxbasis"></span><h3>10.7.1.1. DF auxiliary basis<a class="headerlink" href="#df-auxiliary-basis" title="Permalink to this headline">¶</a></h3>
<p>The default auxiliary basis set are generated by function
<code class="xref py py-func docutils literal notranslate"><span class="pre">pyscf.df.addons.make_basis()</span></code> based on the orbital basis specified in
the calculation according to the rules defined in
<code class="xref py py-data docutils literal notranslate"><span class="pre">pyscf.df.addons.DEFAULT_AUXBASIS</span></code>.
Specifically, the <cite>jkfit</cite> basis in the first column is used for Hartree-Fock or
DFT methods, and the <cite>ri</cite> basis in the second column is used for correlation
calculations. These optimized auxiliary basis sets are obtained from
<a class="reference external" href="http://www.psicode.org/psi4manual/master/basissets_byfamily.html">http://www.psicode.org/psi4manual/master/basissets_byfamily.html</a>
If optimized auxiliary basis set was not found for the orbital basis set,
even-tempered Gaussian functions are generated automatically.</p>
<p>Specifying auxiliary basis is a common requirement in the real applications.
For example, the default auxiliary basis set for the pure DFT calculations may
be over complete since it is designed to represent both the Coulomb and HF
exchange matrix.  Coulomb fitting basis such as Weigend-cfit basis or
Ahlrichs-cfit basis are often enough to obtain chemical accuracy.  To control
the fitting basis in DF method, You can change the value of
<code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df.auxbasis</span></code> attribute.  The input format of auxiliary fitting basis
is exactly the same to the input format of orbital <a class="reference internal" href="gto.html#gto-basis"><span class="std std-ref">basis</span></a> set.  For
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;pbe,pbe&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -109.432313679876</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -109.432329411505</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">auxbasis</span> <span class="o">=</span> <span class="s1">&#39;weigend&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -109.432334646584</span>
</pre></div>
</div>
<p>More examples for inputing auxiliary basis in the DF calculation can be found
in <code class="docutils literal notranslate"><span class="pre">examples/df/01-auxbasis.py</span></code>.</p>
<div class="section" id="even-tempered-auxiliary-gaussian-basis">
<span id="df-etb-auxbasis"></span><h4>10.7.1.1.1. Even-tempered auxiliary Gaussian basis<a class="headerlink" href="#even-tempered-auxiliary-gaussian-basis" title="Permalink to this headline">¶</a></h4>
<p>The even-tempered auxiliary Gaussian basis is generated by function <code class="xref py py-func docutils literal notranslate"><span class="pre">aug_etb()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>                            <span class="c1"># 28</span>
<span class="n">auxbasis</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">make_auxmol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">auxbasis</span><span class="p">)</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>  <span class="c1"># 200</span>
<span class="n">auxbasis</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">make_auxmol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">auxbasis</span><span class="p">)</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>  <span class="c1"># 338</span>
</pre></div>
</div>
<p>Here the <code class="xref py py-func docutils literal notranslate"><span class="pre">make_auxmol()</span></code> function converts the auxbasis to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
object which can be used to evaluate the analytical integrals the same way as
the regular <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object.  The formula to generate the exponents
<span class="math notranslate nohighlight">\(\zeta\)</span> of the even-tempered auxiliary basis are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\varphi &amp;= r^l \exp(-\zeta_{il} r^2), \quad i = 0..n \\
\zeta_{il} &amp;= \alpha \times \beta^i
:label: etb\end{split}\]</div>
<p>The default value of <span class="math notranslate nohighlight">\(\beta\)</span> is 2.3.  <span class="math notranslate nohighlight">\(\alpha\)</span> and the number of
auxiliary basis <span class="math notranslate nohighlight">\(n\)</span> is determined based on the orbital basis.  Given the
orbital basis</p>
<div class="math notranslate nohighlight">
\[\chi = r^l \exp(-\alpha_l r^2)\]</div>
<p>the orbital pair on the same center produces a new one-center basis</p>
<div class="math notranslate nohighlight">
\[\chi \chi' = r^{l+l'} \exp(-(\alpha_l+\alpha_l') r^2)
= r^L \exp(-\alpha_L r^2)\]</div>
<p>The minimal <span class="math notranslate nohighlight">\(\alpha_L\)</span> in all orbital pairs is assigned to <span class="math notranslate nohighlight">\(\alpha\)</span>
in <code class="xref eq docutils literal notranslate"><span class="pre">etb</span></code>.
Then <span class="math notranslate nohighlight">\(n\)</span> is estimated to make the largest auxiliary exponent <span class="math notranslate nohighlight">\(\zeta\)</span>
as close as possible to the maximum <span class="math notranslate nohighlight">\(\alpha_L\)</span>.
The size of generated even-tempered Gaussian basis is typically 5 - 10 times of
the size of the orbital basis, or 2 - 3 times more than the optimized auxiliary
basis.  (Note the accuracy of this even-tempered auxiliary basis is not fully
benchmarked. The error is close to the optimized auxiliary basis in our tests.)</p>
</div>
</div>
<div class="section" id="saving-loading-df-integral-tensor">
<span id="sl-cderi"></span><h3>10.7.1.2. Saving/Loading DF integral tensor<a class="headerlink" href="#saving-loading-df-integral-tensor" title="Permalink to this headline">¶</a></h3>
<p>Although it is not expensive to compute DF integral tensor in the molecular
calculation, saving/loading the 3-index tensor is still useful since it provides
an alternative way, different to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">_eri</span></code> of mean-field object
(see <a class="reference internal" href="scf.html#customize-h"><span class="std std-ref">Customizing Hamiltonian</span></a>), to customize the Hamiltonian.</p>
<p>In the DF-SCF method, the 3-index tensor is held in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> object.
The <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> object (see <a class="reference internal" href="#pyscf.df.df.DF" title="pyscf.df.df.DF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.df.DF</span></code></a> class) provides
two attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi_to_save</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi</span></code> to access the DF 3-index
integrals.</p>
<p>If a DF integral tensor is assigned to <code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi</span></code>, the integrals will be
used in the DF calculation.  The DF integral tensor can be either a numpy array
or an HDF5 file on disk.  When the DF integrals are provided in the HDF5 file,
the integral needs to be stored under the dataset <code class="docutils literal notranslate"><span class="pre">'j3c'</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">df</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 1 0 1; H 0 1 1; H 1 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="n">nao</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;df_ints.h5&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">[</span><span class="s1">&#39;j3c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="n">nao</span><span class="o">*</span><span class="p">(</span><span class="n">nao</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>As shown in the above example, the integral tensor <span class="math notranslate nohighlight">\(V_{x,ij}\)</span> provided in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi</span></code> should be a 2D array in C (row-major) convention. Its first index
corresponds to the auxiliary basis and the second combined index <code class="docutils literal notranslate"><span class="pre">ij</span></code> is the
orbital pair index.  When load DF integrals, we assumed hermitian symmetry
between the two orbital index, ie only the elements <span class="math notranslate nohighlight">\(i\geq j\)</span> are left in
the DF integral tensor.  Thus the DF integral tensor should be a 2D array, with
shape <code class="docutils literal notranslate"><span class="pre">(M,N*(N+1)/2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">M</span></code> is the number of auxiliary functions, N is
the number of orbitals.</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi</span></code> is not specified, the DF integral tensor will be generated
during the calculation and stored to the file that the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi_to_save</span></code> points to.  By default, it is a random file and the
random file will be deleted if the calculation finishes successfully.  You
can find the filename in the output log (when <code class="docutils literal notranslate"><span class="pre">with.verbose</span> <span class="pre">&gt;</span> <span class="pre">3</span></code>, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>******** &lt;class &#39;pyscf.df.df.DF&#39;&gt; flags ********
auxbasis = None
max_memory = 20000
_cderi_to_save = /scratch/tmp6rGrSD
</pre></div>
</div>
<p>If the calculation is terminated problematically with error or any other
reasons, you can reuse the DF integrals in the next calculation by assigning
the integral file to <code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi</span></code>.
Overwriting <code class="xref py py-attr docutils literal notranslate"><span class="pre">_cderi_to_save</span></code> with a filename will make the program save the
DF integrals in the given filename regardless whether the calculation is succeed
or failed.  See also the example
<code class="docutils literal notranslate"><span class="pre">pyscf/examples/df/10-access_df_integrals.py</span></code>.</p>
<div class="section" id="precomputing-the-df-integral-tensor">
<h4>10.7.1.2.1. Precomputing the DF integral tensor<a class="headerlink" href="#precomputing-the-df-integral-tensor" title="Permalink to this headline">¶</a></h4>
<p>The DF integral tensor can be computed without initialization the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> object.  Functions <code class="xref py py-func docutils literal notranslate"><span class="pre">cholesky_eri()</span></code> defined in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">df.incore</span></code> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">df.outcore</span></code> can generate DF integral tensor in memory
or in a HDF5 file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">cderi</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">incore</span><span class="o">.</span><span class="n">cholesky_eri</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">auxbasis</span><span class="o">=</span><span class="s1">&#39;ccpvdz-jkfit&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">outcore</span><span class="o">.</span><span class="n">cholesky_eri</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s1">&#39;df_ints.h5&#39;</span><span class="p">,</span> <span class="n">auxbasis</span><span class="o">=</span><span class="s1">&#39;ccpvdz-jkfit&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>These <code class="docutils literal notranslate"><span class="pre">cderi</span></code> integrals has the same data structure as the one generated in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> object.  They can be directly used in the DF type calculations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">scf</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="n">cderi</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="approximating-orbital-hessian-in-scf-and-mcscf">
<h3>10.7.1.3. Approximating orbital hessian in SCF and MCSCF<a class="headerlink" href="#approximating-orbital-hessian-in-scf-and-mcscf" title="Permalink to this headline">¶</a></h3>
<p>Orbital hessian is required by the second order SCF solver or MCSCF solver.
In many systems, approximating the orbital hessian has negligible effects to the
convergence and the solutions of the SCF or MCSCF orbital optimization procedure.
Using DF method to approximate the orbital hessian can improve the overall
performance.  For example, the following code enables the DF approximation to
the orbital hessian in SCF calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; O 0 0 1.5&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># converged SCF energy = -129.0896469563</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>                         <span class="c1"># converged SCF energy = -129.0896469563</span>
</pre></div>
</div>
<p>The approximation to orbital hessian does not change the SCF result.  In the
above example, it produces the same solution to the regular SCF result.
Similarly, when the DF approximation is used with CASSCF orbital hessian, the
CASSCF result should not change.  Continuing the above example, we can use the
<code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.approx_hessian()</span></code> function to change the orbital hessian of the given
CASSCF object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">mcscf</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">approx_hessian</span><span class="p">(</span><span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -129.283077136</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>                        <span class="c1"># -129.283077136</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the second order SCF solver, the order to apply the density_fit
and newton methods affects the character of the resultant SCF object.  For
example, the statement <code class="docutils literal notranslate"><span class="pre">mf</span> <span class="pre">=</span> <span class="pre">scf.RHF(mol).density_fit().newton()</span></code> first
produces a DFHF object then enable the second order Newton solver for the DFHF
object.  The resultant SCF object is a DFHF object.  See more examples in
<code class="docutils literal notranslate"><span class="pre">examples/scf/23-decorate_scf.py</span></code></p>
</div>
</div>
</div>
<div class="section" id="examples">
<h2>10.7.2. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Relevant examples
<code class="file docutils literal notranslate"><span class="pre">examples/df/00-with_df.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/01-auxbasis.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/10-access_df_integrals.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/11-get_j_io_free.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/40-precompute_df_integrals.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/40-custom_df_hamiltonian.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/41-df_integrals_gradients.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/df/42-overwrite_get_jk.py</span></code></p>
</div>
<div class="section" id="program-reference">
<h2>10.7.3. Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="df-class">
<h3>10.7.3.1. DF class<a class="headerlink" href="#df-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.df.df.DF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.df.</code><code class="sig-name descname">DF</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxbasis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df.DF" title="Permalink to this definition">¶</a></dt>
<dd><p>Object to hold 3-index tensor</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>auxbasis<span class="classifier">str or dict</span></dt><dd><p>Same input format as <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code></p>
</dd>
<dt>auxmol<span class="classifier">Mole object</span></dt><dd><p>Read only Mole object to hold the auxiliary basis.  auxmol is
generated automatically in the initialization step based on the
given auxbasis.  It is used in the rest part of the code to
determine the problem size, the integral batches etc.  This object
should NOT be modified.</p>
</dd>
<dt>_cderi_to_save<span class="classifier">str</span></dt><dd><p>If _cderi_to_save is specified, the DF integral tensor will be
saved in this file.</p>
</dd>
<dt>_cderi<span class="classifier">str or numpy array</span></dt><dd><p>If _cderi is specified, the DF integral tensor will be read from
this HDF5 file (or numpy array). When the DF integral tensor is
provided from the HDF5 file, it has to be stored under the dataset
‘j3c’.
The DF integral tensor <span class="math notranslate nohighlight">\(V_{x,ij}\)</span> should be a 2D array in C
(row-major) convention, where x corresponds to index of auxiliary
basis, and the combined index ij is the orbital pair index. The
hermitian symmetry is assumed for the combined ij index, ie
the elements of <span class="math notranslate nohighlight">\(V_{x,i,j}\)</span> with <span class="math notranslate nohighlight">\(i\geq j\)</span> are existed
in the DF integral tensor.  Thus the shape of DF integral tensor
is (M,N*(N+1)/2), where M is the number of auxbasis functions and
N is the number of basis functions of the orbital basis.</p>
</dd>
<dt>blockdim<span class="classifier">int</span></dt><dd><p>When reading DF integrals from disk the chunk size to load.  It is
used to improve IO performance.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.df.df.DF.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df.DF.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.df.df.DF.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df.DF.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyscf.df.incore">
<span id="df-incore"></span><h3>10.7.3.2. df.incore<a class="headerlink" href="#module-pyscf.df.incore" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.incore.aux_e1">
<code class="sig-prename descclassname">pyscf.df.incore.</code><code class="sig-name descname">aux_e1</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxmol</em>, <em class="sig-param">intor='int3c2e'</em>, <em class="sig-param">aosym='s1'</em>, <em class="sig-param">comp=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/incore.html#aux_e1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.aux_e1" title="Permalink to this definition">¶</a></dt>
<dd><p>3-center 2-electron AO integrals (L|ij), where L is the auxiliary basis.</p>
<p>Note aux_e1 is basically analogous to aux_e2 function. It can be viewed as
the version of transposed aux_e2 tensor:
if comp == 1:</p>
<blockquote>
<div><p>aux_e1 = aux_e2().T</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>aux_e1 = aux_e2().transpose(0,2,1)</p>
</dd>
</dl>
<p>The same arguments as function aux_e2 can be input to aux_e1.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.aux_e2">
<code class="sig-prename descclassname">pyscf.df.incore.</code><code class="sig-name descname">aux_e2</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxmol</em>, <em class="sig-param">intor='int3c2e'</em>, <em class="sig-param">aosym='s1'</em>, <em class="sig-param">comp=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">cintopt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/incore.html#aux_e2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.aux_e2" title="Permalink to this definition">¶</a></dt>
<dd><p>3-center AO integrals (ij|L), where L is the auxiliary basis.</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>cintopt<span class="classifier">Libcint-3.14 and newer version support to compute int3c2e</span></dt><dd><p>without the opt for the 3rd index.  It can be precomputed to
reduce the overhead of cintopt initialization repeatedly.</p>
<p>cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas, mol._env, ‘int3c2e’)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.cholesky_eri">
<code class="sig-prename descclassname">pyscf.df.incore.</code><code class="sig-name descname">cholesky_eri</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxbasis='weigend+etb'</em>, <em class="sig-param">auxmol=None</em>, <em class="sig-param">int3c='int3c2e'</em>, <em class="sig-param">aosym='s2ij'</em>, <em class="sig-param">int2c='int2c2e'</em>, <em class="sig-param">comp=1</em>, <em class="sig-param">max_memory=2000</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">fauxe2=&lt;function aux_e2&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/incore.html#cholesky_eri"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.cholesky_eri" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>2D array of (naux,nao*(nao+1)/2) in C-contiguous</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.cholesky_eri_debug">
<code class="sig-prename descclassname">pyscf.df.incore.</code><code class="sig-name descname">cholesky_eri_debug</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxbasis='weigend+etb'</em>, <em class="sig-param">auxmol=None</em>, <em class="sig-param">int3c='int3c2e'</em>, <em class="sig-param">aosym='s2ij'</em>, <em class="sig-param">int2c='int2c2e'</em>, <em class="sig-param">comp=1</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">fauxe2=&lt;function aux_e2&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/incore.html#cholesky_eri_debug"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.cholesky_eri_debug" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>2D array of (naux,nao*(nao+1)/2) in C-contiguous</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.fill_2c2e">
<code class="sig-prename descclassname">pyscf.df.incore.</code><code class="sig-name descname">fill_2c2e</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxmol</em>, <em class="sig-param">intor='int2c2e'</em>, <em class="sig-param">comp=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/incore.html#fill_2c2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.fill_2c2e" title="Permalink to this definition">¶</a></dt>
<dd><p>2-center 2-electron AO integrals for auxiliary basis (auxmol)</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.df.outcore">
<span id="df-outcore"></span><h3>10.7.3.3. df.outcore<a class="headerlink" href="#module-pyscf.df.outcore" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.outcore.cholesky_eri">
<code class="sig-prename descclassname">pyscf.df.outcore.</code><code class="sig-name descname">cholesky_eri</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">erifile</em>, <em class="sig-param">auxbasis='weigend+etb'</em>, <em class="sig-param">dataname='j3c'</em>, <em class="sig-param">tmpdir=None</em>, <em class="sig-param">int3c='int3c2e'</em>, <em class="sig-param">aosym='s2ij'</em>, <em class="sig-param">int2c='int2c2e'</em>, <em class="sig-param">comp=1</em>, <em class="sig-param">max_memory=2000</em>, <em class="sig-param">auxmol=None</em>, <em class="sig-param">verbose=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/outcore.html#cholesky_eri"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.outcore.cholesky_eri" title="Permalink to this definition">¶</a></dt>
<dd><p>3-index density-fitting tensor.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.outcore.cholesky_eri_b">
<code class="sig-prename descclassname">pyscf.df.outcore.</code><code class="sig-name descname">cholesky_eri_b</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">erifile</em>, <em class="sig-param">auxbasis='weigend+etb'</em>, <em class="sig-param">dataname='j3c'</em>, <em class="sig-param">int3c='int3c2e'</em>, <em class="sig-param">aosym='s2ij'</em>, <em class="sig-param">int2c='int2c2e'</em>, <em class="sig-param">comp=1</em>, <em class="sig-param">max_memory=2000</em>, <em class="sig-param">auxmol=None</em>, <em class="sig-param">verbose=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/outcore.html#cholesky_eri_b"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.outcore.cholesky_eri_b" title="Permalink to this definition">¶</a></dt>
<dd><p>3-center 2-electron DF tensor. Similar to cholesky_eri while this
function stores DF tensor in blocks.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.outcore.general">
<code class="sig-prename descclassname">pyscf.df.outcore.</code><code class="sig-name descname">general</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">mo_coeffs</em>, <em class="sig-param">erifile</em>, <em class="sig-param">auxbasis='weigend+etb'</em>, <em class="sig-param">dataname='eri_mo'</em>, <em class="sig-param">tmpdir=None</em>, <em class="sig-param">int3c='int3c2e'</em>, <em class="sig-param">aosym='s2ij'</em>, <em class="sig-param">int2c='int2c2e'</em>, <em class="sig-param">comp=1</em>, <em class="sig-param">max_memory=2000</em>, <em class="sig-param">verbose=0</em>, <em class="sig-param">compact=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/outcore.html#general"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.outcore.general" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform ij of (ij|L) to MOs.</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.df.addons">
<span id="df-addons"></span><h3>10.7.3.4. df.addons<a class="headerlink" href="#module-pyscf.df.addons" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.addons.aug_etb">
<code class="sig-prename descclassname">pyscf.df.addons.</code><code class="sig-name descname">aug_etb</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">beta=2.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/addons.html#aug_etb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.aug_etb" title="Permalink to this definition">¶</a></dt>
<dd><p>To generate the even-tempered auxiliary Gaussian basis</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.addons.aug_etb_for_dfbasis">
<code class="sig-prename descclassname">pyscf.df.addons.</code><code class="sig-name descname">aug_etb_for_dfbasis</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">dfbasis='weigend'</em>, <em class="sig-param">beta=2.0</em>, <em class="sig-param">start_at=36</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/addons.html#aug_etb_for_dfbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.aug_etb_for_dfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>augment weigend basis with even-tempered gaussian basis
exps = alpha*beta^i for i = 1..N</p>
</dd></dl>

<dl class="class">
<dt id="pyscf.df.addons.load">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.addons.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">eri</em>, <em class="sig-param">dataname='j3c'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/addons.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load 3c2e integrals from hdf5 file. It can be used in the context
manager:</p>
<dl class="simple">
<dt>with load(cderifile) as eri:</dt><dd><p>print(eri.shape)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.addons.make_auxbasis">
<code class="sig-prename descclassname">pyscf.df.addons.</code><code class="sig-name descname">make_auxbasis</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">mp2fit=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/addons.html#make_auxbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.make_auxbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Depending on the orbital basis, generating even-tempered Gaussians or
the optimized auxiliary basis defined in DEFAULT_AUXBASIS</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.addons.make_auxmol">
<code class="sig-prename descclassname">pyscf.df.addons.</code><code class="sig-name descname">make_auxmol</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxbasis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/addons.html#make_auxmol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.make_auxmol" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a fake Mole object which uses the density fitting auxbasis as
the basis sets.  If auxbasis is not specified, the optimized auxiliary fitting
basis set will be generated according to the rules recorded in
pyscf.df.addons.DEFAULT_AUXBASIS.  If the optimized auxiliary basis is not
available (either not specified in DEFAULT_AUXBASIS or the basis set of the
required elements not defined in the optimized auxiliary basis),
even-tempered Gaussian basis set will be generated.</p>
<p>See also the paper JCTC, 13, 554 about generating auxiliary fitting basis.</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.df.df">
<span id="df-df"></span><h3>10.7.3.5. df.df<a class="headerlink" href="#module-pyscf.df.df" title="Permalink to this headline">¶</a></h3>
<p>J-metric density fitting</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.df.</code><code class="sig-name descname">DF</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxbasis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Object to hold 3-index tensor</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>auxbasis<span class="classifier">str or dict</span></dt><dd><p>Same input format as <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code></p>
</dd>
<dt>auxmol<span class="classifier">Mole object</span></dt><dd><p>Read only Mole object to hold the auxiliary basis.  auxmol is
generated automatically in the initialization step based on the
given auxbasis.  It is used in the rest part of the code to
determine the problem size, the integral batches etc.  This object
should NOT be modified.</p>
</dd>
<dt>_cderi_to_save<span class="classifier">str</span></dt><dd><p>If _cderi_to_save is specified, the DF integral tensor will be
saved in this file.</p>
</dd>
<dt>_cderi<span class="classifier">str or numpy array</span></dt><dd><p>If _cderi is specified, the DF integral tensor will be read from
this HDF5 file (or numpy array). When the DF integral tensor is
provided from the HDF5 file, it has to be stored under the dataset
‘j3c’.
The DF integral tensor <span class="math notranslate nohighlight">\(V_{x,ij}\)</span> should be a 2D array in C
(row-major) convention, where x corresponds to index of auxiliary
basis, and the combined index ij is the orbital pair index. The
hermitian symmetry is assumed for the combined ij index, ie
the elements of <span class="math notranslate nohighlight">\(V_{x,i,j}\)</span> with <span class="math notranslate nohighlight">\(i\geq j\)</span> are existed
in the DF integral tensor.  Thus the shape of DF integral tensor
is (M,N*(N+1)/2), where M is the number of auxbasis functions and
N is the number of basis functions of the orbital basis.</p>
</dd>
<dt>blockdim<span class="classifier">int</span></dt><dd><p>When reading DF integrals from disk the chunk size to load.  It is
used to improve IO performance.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt>
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF.kernel"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF.reset"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyscf.df.df.DF4C">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.df.</code><code class="sig-name descname">DF4C</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">auxbasis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df.html#DF4C"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df.DF4C" title="Permalink to this definition">¶</a></dt>
<dd><p>Relativistic 4-component</p>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.df.df.GDF">
<code class="sig-prename descclassname">pyscf.df.df.</code><code class="sig-name descname">GDF</code><a class="headerlink" href="#pyscf.df.df.GDF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.df.df.DF" title="pyscf.df.df.DF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.df.DF</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.df.df.GDF4C">
<code class="sig-prename descclassname">pyscf.df.df.</code><code class="sig-name descname">GDF4C</code><a class="headerlink" href="#pyscf.df.df.GDF4C" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.df.df.DF4C" title="pyscf.df.df.DF4C"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.df.DF4C</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.df.df_jk">
<span id="df-df-jk"></span><h3>10.7.3.6. df.df_jk<a class="headerlink" href="#module-pyscf.df.df_jk" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.df_jk.density_fit">
<code class="sig-prename descclassname">pyscf.df.df_jk.</code><code class="sig-name descname">density_fit</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">auxbasis=None</em>, <em class="sig-param">with_df=None</em>, <em class="sig-param">only_dfj=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df_jk.html#density_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df_jk.density_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>For the given SCF object, update the J, K matrix constructor with
corresponding density fitting integrals.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : an SCF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>auxbasis<span class="classifier">str or basis dict</span></dt><dd><p>Same format to the input attribute mol.basis.  If auxbasis is
None, optimal auxiliary basis based on AO basis (if possible) or
even-tempered Gaussian basis will be used.</p>
</dd>
<dt>only_dfj<span class="classifier">str</span></dt><dd><p>Compute Coulomb integrals only and no approximation for HF
exchange. Same to RIJONX in ORCA</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An SCF object with a modified J, K matrix constructor which uses density
fitting integrals to compute J and K</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-100.005306000435510</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-100.005306000435510</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.df_jk.r_get_jk">
<code class="sig-prename descclassname">pyscf.df.df_jk.</code><code class="sig-name descname">r_get_jk</code><span class="sig-paren">(</span><em class="sig-param">dfobj</em>, <em class="sig-param">dms</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">with_j=True</em>, <em class="sig-param">with_k=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/df_jk.html#r_get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df_jk.r_get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Relativistic density fitting JK</p>
</dd></dl>

</div>
<div class="section" id="df-r-incore">
<h3>10.7.3.7. df.r_incore<a class="headerlink" href="#df-r-incore" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.r_incore"></span></div>
<div class="section" id="df-grad-rhf">
<h3>10.7.3.8. df.grad.rhf<a class="headerlink" href="#df-grad-rhf" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.grad.rhf"></span><dl class="attribute">
<dt id="pyscf.df.grad.rhf.Grad">
<code class="sig-prename descclassname">pyscf.df.grad.rhf.</code><code class="sig-name descname">Grad</code><a class="headerlink" href="#pyscf.df.grad.rhf.Grad" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.df.grad.rhf.Gradients" title="pyscf.df.grad.rhf.Gradients"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.grad.rhf.Gradients</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.df.grad.rhf.Gradients">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.grad.rhf.</code><code class="sig-name descname">Gradients</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/rhf.html#Gradients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.rhf.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Restricted density-fitting Hartree-Fock gradients</p>
<dl class="method">
<dt id="pyscf.df.grad.rhf.Gradients.extra_force">
<code class="sig-name descname">extra_force</code><span class="sig-paren">(</span><em class="sig-param">atom_id</em>, <em class="sig-param">envs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/rhf.html#Gradients.extra_force"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.rhf.Gradients.extra_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook for extra contributions in analytical gradients.</p>
<p>Contributions like the response of auxiliary basis in density fitting
method, the grid response in DFT numerical integration can be put in
this function.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="df-grad-uhf">
<h3>10.7.3.9. df.grad.uhf<a class="headerlink" href="#df-grad-uhf" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.grad.uhf"></span><dl class="attribute">
<dt id="pyscf.df.grad.uhf.Grad">
<code class="sig-prename descclassname">pyscf.df.grad.uhf.</code><code class="sig-name descname">Grad</code><a class="headerlink" href="#pyscf.df.grad.uhf.Grad" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.df.grad.uhf.Gradients" title="pyscf.df.grad.uhf.Gradients"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.grad.uhf.Gradients</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.df.grad.uhf.Gradients">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.grad.uhf.</code><code class="sig-name descname">Gradients</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/uhf.html#Gradients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.uhf.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Unrestricted density-fitting Hartree-Fock gradients</p>
<dl class="method">
<dt id="pyscf.df.grad.uhf.Gradients.extra_force">
<code class="sig-name descname">extra_force</code><span class="sig-paren">(</span><em class="sig-param">atom_id</em>, <em class="sig-param">envs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/uhf.html#Gradients.extra_force"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.uhf.Gradients.extra_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook for extra contributions in analytical gradients.</p>
<p>Contributions like the response of auxiliary basis in density fitting
method, the grid response in DFT numerical integration can be put in
this function.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="df-grad-rks">
<h3>10.7.3.10. df.grad.rks<a class="headerlink" href="#df-grad-rks" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.grad.rks"></span><dl class="attribute">
<dt id="pyscf.df.grad.rks.Grad">
<code class="sig-prename descclassname">pyscf.df.grad.rks.</code><code class="sig-name descname">Grad</code><a class="headerlink" href="#pyscf.df.grad.rks.Grad" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.df.grad.rks.Gradients" title="pyscf.df.grad.rks.Gradients"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.grad.rks.Gradients</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.df.grad.rks.Gradients">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.grad.rks.</code><code class="sig-name descname">Gradients</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/rks.html#Gradients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.rks.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.df.grad.rks.Gradients.extra_force">
<code class="sig-name descname">extra_force</code><span class="sig-paren">(</span><em class="sig-param">atom_id</em>, <em class="sig-param">envs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/rks.html#Gradients.extra_force"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.rks.Gradients.extra_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook for extra contributions in analytical gradients.</p>
<p>Contributions like the response of auxiliary basis in density fitting
method, the grid response in DFT numerical integration can be put in
this function.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.df.grad.rks.Gradients.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.df.grad.rks.Gradients.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.df.grad.rks.get_veff">
<code class="sig-prename descclassname">pyscf.df.grad.rks.</code><code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">ks_grad</em>, <em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/rks.html#get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.rks.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional</p>
</dd></dl>

</div>
<div class="section" id="df-grad-uks">
<h3>10.7.3.11. df.grad.uks<a class="headerlink" href="#df-grad-uks" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.grad.uks"></span><dl class="attribute">
<dt id="pyscf.df.grad.uks.Grad">
<code class="sig-prename descclassname">pyscf.df.grad.uks.</code><code class="sig-name descname">Grad</code><a class="headerlink" href="#pyscf.df.grad.uks.Grad" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.df.grad.uks.Gradients" title="pyscf.df.grad.uks.Gradients"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.df.grad.uks.Gradients</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.df.grad.uks.Gradients">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.grad.uks.</code><code class="sig-name descname">Gradients</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/uks.html#Gradients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.uks.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.df.grad.uks.Gradients.extra_force">
<code class="sig-name descname">extra_force</code><span class="sig-paren">(</span><em class="sig-param">atom_id</em>, <em class="sig-param">envs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/uks.html#Gradients.extra_force"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.uks.Gradients.extra_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook for extra contributions in analytical gradients.</p>
<p>Contributions like the response of auxiliary basis in density fitting
method, the grid response in DFT numerical integration can be put in
this function.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.df.grad.uks.Gradients.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.df.grad.uks.Gradients.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.df.grad.uks.get_veff">
<code class="sig-prename descclassname">pyscf.df.grad.uks.</code><code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">ks_grad</em>, <em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/grad/uks.html#get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.grad.uks.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb + XC functional</p>
</dd></dl>

</div>
<div class="section" id="df-hessian-rhf">
<h3>10.7.3.12. df.hessian.rhf<a class="headerlink" href="#df-hessian-rhf" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.hessian.rhf"></span><p>Non-relativistic RHF analytical Hessian with density-fitting approximation</p>
<p>Ref:
[1] Efficient implementation of the analytic second derivatives of</p>
<blockquote>
<div><p>Hartree-Fock and hybrid DFT energies: a detailed analysis of different
approximations.  Dmytro Bykov, Taras Petrenko, Robert Izsak, Simone
Kossmann, Ute Becker, Edward Valeev, Frank Neese. Mol. Phys. 113, 1961 (2015)</p>
</div></blockquote>
<dl class="class">
<dt id="pyscf.df.hessian.rhf.Hessian">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.hessian.rhf.</code><code class="sig-name descname">Hessian</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/hessian/rhf.html#Hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.hessian.rhf.Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic restricted Hartree-Fock hessian</p>
</dd></dl>

</div>
<div class="section" id="df-hessian-uhf">
<h3>10.7.3.13. df.hessian.uhf<a class="headerlink" href="#df-hessian-uhf" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.hessian.uhf"></span><p>Non-relativistic UHF analytical Hessian</p>
<dl class="class">
<dt id="pyscf.df.hessian.uhf.Hessian">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.hessian.uhf.</code><code class="sig-name descname">Hessian</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/hessian/uhf.html#Hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.hessian.uhf.Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic UHF hessian</p>
</dd></dl>

</div>
<div class="section" id="df-hessian-rks">
<h3>10.7.3.14. df.hessian.rks<a class="headerlink" href="#df-hessian-rks" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.hessian.rks"></span><p>Non-relativistic RKS analytical Hessian</p>
<dl class="class">
<dt id="pyscf.df.hessian.rks.Hessian">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.hessian.rks.</code><code class="sig-name descname">Hessian</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/hessian/rks.html#Hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.hessian.rks.Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic RKS hessian</p>
</dd></dl>

</div>
<div class="section" id="df-hessian-uks">
<h3>10.7.3.15. df.hessian.uks<a class="headerlink" href="#df-hessian-uks" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.df.hessian.uks"></span><p>Non-relativistic UKS analytical Hessian</p>
<dl class="class">
<dt id="pyscf.df.hessian.uks.Hessian">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.df.hessian.uks.</code><code class="sig-name descname">Hessian</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/df/hessian/uks.html#Hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.hessian.uks.Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic RKS hessian</p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dft.html" class="btn btn-neutral float-right" title="10.8. dft — Density functional theory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="data.html" class="btn btn-neutral float-left" title="10.6. data — Data for constants" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2015-2020, The PySCF Developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>